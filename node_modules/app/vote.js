var { GuildChannel, RichEmbed } = require("discord.js");
var running = [];

function getScope(channel) {
	return channel instanceof GuildChannel ? channel.guild.id : channel.id;
}

function replaceTags(content, values) {
	var result = content;
	if (content instanceof RichEmbed) {
		result.setTitle(replaceTags(content.title, values));
		result.setDescription(replaceTags(content.description, values));
		result.setFooter(replaceTags(content.footer, values));
	} else {
		values.forEach((value) => {
			result = result.replace(value.tag, value.value);
		});
	}
	return result;
}

module.exports = function vote(time, channel, required,
	filter = () => { return true; },
	id = null,
	content = "A vote is required (<current>/<required>)!") {
	// If running contains [guild.id, channel.id], return rejected promise.
	var result;
	if (id != null && running.some((other) => getScope(channel) == other.scope && other.id === id)) {
		console.log("duplicate");
		result = Promise.reject(new Error(`The vote for ${id} is still running.`));
	} else {
		if (id != null)
			running.push({scope: getScope(channel), id: id});

		result = new Promise((resolve, reject) => {
			try {
				channel.send(replaceTags(content, [{tag: "<current>", value: 0}, {tag: "<required>", value: required}])).then((message) => {
					message.react("ðŸ‘").then((upVote) => {
						var finish, timeout;
						var getTally = () => {
							return message.reactions.first().users.filter((user) => { return filter(user); }).size - 1;
						};
						var updateMessage = (reaction) => {
							var tally = getTally();
							console.log(tally);
							if (reaction.message.id === message.id)
								message.edit(replaceTags(content, [{tag: "<current>", value: tally}, {tag: "<required>", value: required}]));
							if (tally >= required)
								finish();
						};
						finish = () => {
							clearTimeout(timeout);
							channel.client.removeListener("messageReactionAdd", updateMessage);
							channel.client.removeListener("messageReactionRemove", updateMessage);
							if (id != null)
								running.splice(running.indexOf(running.find((other) => getScope(channel) == other.scope && other.id === id)), 1);
							resolve(getTally() > 0);
						};
						
						channel.client.on("messageReactionAdd", updateMessage);
						channel.client.on("messageReactionRemove", updateMessage);
						timeout = channel.client.setTimeout(finish, time);
					});
				});
			} catch(exc) {
				console.log("error");
				console.log(exc);
				reject(exc);
			}
		});
	}
	return result;
}
